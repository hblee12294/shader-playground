{"version":3,"sources":["assets/water.jpg","utils/threeUtils.ts","apps/Basic.ts","pages/Basic/Basic.tsx","apps/SpikySphere.ts","configs/routes.ts","pages/SpikySphere/SpikySphere.tsx","commons/Layout/Layout.tsx","App.tsx","index.tsx"],"names":["module","exports","resizeRendererToDisplaySize","renderer","canvas","domElement","pixelRatio","window","devicePixelRatio","width","clientWidth","height","clientHeight","needResize","setSize","App","container","camera","scene","disposed","init","tick","dispose","aspect","updateProjectionMatrix","render","requestAnimationFrame","this","WebGLRenderer","append","PerspectiveCamera","position","z","Scene","background","Color","geometry","SphereBufferGeometry","material","ShaderMaterial","vertexShader","fragmentShader","sphere","Mesh","add","Basic","rootRef","useRef","useEffect","root","current","app","className","ref","displacement","noise","uniforms","time","Date","now","rotation","y","amplitude","value","Math","sin","color","offsetHSL","i","length","random","MathUtils","clamp","attributes","needsUpdate","Float32Array","count","setAttribute","BufferAttribute","colorTexture","TextureLoader","load","waterURL","wrapS","wrapT","RepeatWrapping","routes","path","exact","title","page","ITEMS","map","item","itemId","Layout","children","history","useHistory","location","useLocation","useState","pathname","activeItemId","setActiveItemId","items","onChange","event","preventDefault","push","route","key","component","engine","Styletron","ReactDOM","StrictMode","theme","DarkTheme","document","getElementById"],"mappings":"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","file":"static/js/main.7800f1f6.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/water.bcfb9394.jpg\";","import { WebGLRenderer } from 'three'\n\nexport const resizeRendererToDisplaySize = (renderer: WebGLRenderer) => {\n  const canvas = renderer.domElement\n  const pixelRatio = window.devicePixelRatio\n  const width = (canvas.clientWidth * pixelRatio) | 0\n  const height = (canvas.clientHeight * pixelRatio) | 0\n\n  const needResize = canvas.width !== width || canvas.height !== height\n\n  if (needResize) {\n    renderer.setSize(width, height, false)\n  }\n\n  return needResize\n}\n","import { WebGLRenderer, PerspectiveCamera, Scene, Color, SphereBufferGeometry, ShaderMaterial, Mesh } from 'three'\nimport { resizeRendererToDisplaySize } from 'utils'\n\nconst vertex = `\n  varying vec3 vNormal;\n\n  void main() {\n    vNormal = normal;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`\n\nconst fragment = `\n  varying vec3 vNormal;\n\n  void main() {\n    vec3 light = vec3(0.5, 0.2, 0.1);\n\n    light = normalize(light);\n\n    float dProd = max(0.0, dot(vNormal, light));\n\n    gl_FragColor = vec4(dProd, dProd, dProd, 1.0);\n  }\n`\n\nclass App {\n  private container: HTMLDivElement\n  private renderer: WebGLRenderer\n  private camera: PerspectiveCamera\n  private scene: Scene\n  private disposed: boolean\n\n  constructor(container: HTMLDivElement) {\n    this.container = container\n\n    this.renderer = new WebGLRenderer()\n    this.container.append(this.renderer.domElement)\n\n    this.camera = new PerspectiveCamera(45, container.clientHeight / container.clientWidth, 0.1, 10000)\n    this.camera.position.z = 300\n\n    this.scene = new Scene()\n    this.scene.background = new Color(0x101010)\n\n    // Geometry\n    const geometry = new SphereBufferGeometry(50, 128, 64)\n\n    // Material\n    const material = new ShaderMaterial({\n      vertexShader: vertex,\n      fragmentShader: fragment,\n    })\n\n    const sphere = new Mesh(geometry, material)\n    this.scene.add(sphere)\n\n    this.disposed = false\n  }\n\n  init = () => {\n    this.tick()\n  }\n\n  dispose = () => {\n    this.disposed = true\n  }\n\n  tick = () => {\n    if (this.disposed || !this) return\n\n    if (resizeRendererToDisplaySize(this.renderer)) {\n      const canvas = this.renderer.domElement\n      this.camera.aspect = canvas.clientWidth / canvas.clientHeight\n      this.camera.updateProjectionMatrix()\n    }\n\n    this.renderer.render(this.scene, this.camera)\n\n    requestAnimationFrame(this.tick)\n  }\n}\n\nexport default App\n","import React, { useRef, useEffect } from 'react'\nimport './Basic.scss'\n\nimport App from 'apps/Basic'\n\nconst Basic: React.FC = () => {\n  const rootRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    const root = rootRef.current\n\n    if (!root) return\n\n    const app = new App(root)\n    app.init()\n\n    return () => {\n      app.dispose()\n    }\n  }, [])\n\n  return <div className=\"basic\" ref={rootRef}></div>\n}\n\nexport default Basic\n","import {\n  WebGLRenderer,\n  PerspectiveCamera,\n  Scene,\n  Mesh,\n  ShaderMaterial,\n  SphereBufferGeometry,\n  Color,\n  BufferAttribute,\n  MathUtils,\n  BufferGeometry,\n  TextureLoader,\n  Texture,\n  RepeatWrapping,\n} from 'three'\nimport { resizeRendererToDisplaySize } from 'utils'\n\nimport waterURL from 'assets/water.jpg'\n\nconst vertext = `\n  uniform float amplitude;\n\n  attribute float displacement;\n\n  varying vec3 vNormal;\n  varying vec2 vUv;\n\n  void main() {\n    vNormal = normal;\n    vUv= (0.5 + amplitude) * uv + vec2(amplitude);\n\n    vec3 newPosition = position + amplitude * normal * vec3(displacement);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n  }\n`\n\nconst fragment = `\n  varying vec3 vNormal;\n  varying vec2 vUv;\n\n  uniform vec3 color;\n  uniform sampler2D colorTexture;\n\n  void main() {\n    vec3 light = vec3(0.5, 0.2, 0.1);\n\n    light = normalize(light);\n\n    float dProd = dot(vNormal, light) * 0.5 + 0.5;\n\n    vec4 tcolor = texture2D(colorTexture, vUv);\n    vec4 gray = vec4(vec3(tcolor.r * 0.3 + tcolor.g * 0.59 + tcolor.b * 0.11), 1.0);\n\n    gl_FragColor = gray * vec4(vec3(dProd) * vec3(color), 1.0);\n  }\n`\n\nclass App {\n  private container: HTMLDivElement\n  private renderer: WebGLRenderer\n  private camera: PerspectiveCamera\n  private scene: Scene\n  private disposed: boolean\n  private displacement: Float32Array\n  private noise: Float32Array\n  private sphere: Mesh\n  private uniforms: {\n    amplitude: { value: number }\n    color: { value: Color }\n    colorTexture: { value: Texture }\n  }\n\n  constructor(container: HTMLDivElement) {\n    this.container = container\n\n    this.renderer = new WebGLRenderer()\n    this.container.append(this.renderer.domElement)\n\n    this.camera = new PerspectiveCamera(45, container.clientHeight / container.clientWidth, 0.1, 10000)\n    this.camera.position.z = 300\n\n    this.scene = new Scene()\n    this.scene.background = new Color(0x101010)\n\n    // Geometry\n    const geometry = new SphereBufferGeometry(50, 128, 64)\n    const position = (geometry.attributes as any).position\n\n    this.displacement = new Float32Array(position.count)\n    this.noise = new Float32Array(position.count)\n\n    for (let i = 0; i < this.displacement.length; ++i) {\n      this.noise[i] = Math.random() * 5\n    }\n\n    geometry.setAttribute('displacement', new BufferAttribute(this.displacement, 1))\n\n    // Material\n    this.uniforms = {\n      amplitude: { value: 1.0 },\n      color: { value: new Color(0xff2200) },\n      colorTexture: { value: new TextureLoader().load(waterURL) },\n    }\n    this.uniforms.colorTexture.value.wrapS = this.uniforms.colorTexture.value.wrapT = RepeatWrapping\n\n    const material = new ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vertext,\n      fragmentShader: fragment,\n    })\n\n    this.sphere = new Mesh(geometry, material)\n    this.scene.add(this.sphere)\n\n    this.disposed = false\n  }\n\n  init = () => {\n    this.tick()\n  }\n\n  dispose() {\n    this.disposed = true\n  }\n\n  tick = () => {\n    if (this.disposed || !this) return\n\n    if (resizeRendererToDisplaySize(this.renderer)) {\n      const canvas = this.renderer.domElement\n      this.camera.aspect = canvas.clientWidth / canvas.clientHeight\n      this.camera.updateProjectionMatrix()\n    }\n\n    const time = Date.now() * 0.01\n\n    this.sphere.rotation.y = this.sphere.rotation.z = 0.01 * time\n\n    this.uniforms.amplitude.value = 2.5 * Math.sin(this.sphere.rotation.y * 0.125)\n    this.uniforms.color.value.offsetHSL(0.0005, 0, 0)\n\n    for (let i = 0; i < this.displacement.length; ++i) {\n      this.displacement[i] = Math.sin(0.1 * i + time)\n\n      this.noise[i] += 0.5 * (0.5 - Math.random())\n      this.noise[i] = MathUtils.clamp(this.noise[i], -5, 5)\n\n      this.displacement[i] += this.noise[i]\n    }\n\n    ;((this.sphere.geometry as BufferGeometry).attributes.displacement as BufferAttribute).needsUpdate = true\n\n    this.renderer.render(this.scene, this.camera)\n\n    requestAnimationFrame(this.tick)\n  }\n}\n\nexport default App\n","import { Routes } from 'types'\nimport { Basic, SpikySphere } from 'pages'\n\nconst routes: Routes = [\n  {\n    path: '/basic',\n    exact: true,\n    title: 'Basic',\n    page: Basic,\n  },\n  {\n    path: '/spiky_sphere',\n    exact: true,\n    title: 'Spiky Sphere',\n    page: SpikySphere,\n  },\n]\n\nexport default routes\n","import React, { useRef, useEffect } from 'react'\nimport './SpikySphere.scss'\n\nimport App from 'apps/SpikySphere'\n\nconst SpikySphere: React.FC = () => {\n  const rootRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    const root = rootRef.current\n\n    if (!root) return\n\n    const app = new App(root)\n    app.init()\n\n    return () => {\n      app.dispose()\n    }\n  }, [])\n\n  return <div className=\"spiky-sphere\" ref={rootRef}></div>\n}\n\nexport default SpikySphere\n","import React, { useState } from 'react'\nimport './Layout.scss'\nimport { Navigation } from 'baseui/side-navigation'\nimport { useHistory, useLocation } from 'react-router-dom'\n\nimport { routes } from 'configs'\n\nconst ITEMS = routes.map((item) => ({ title: item.title, itemId: item.path }))\n\nconst Layout: React.FC = ({ children }) => {\n  const history = useHistory()\n  const location = useLocation()\n\n  const [activeItemId, setActiveItemId] = useState(location.pathname)\n\n  return (\n    <div className=\"layout\">\n      <div className=\"nav\">\n        <Navigation\n          items={ITEMS}\n          activeItemId={activeItemId}\n          onChange={({ event, item }) => {\n            event.preventDefault()\n\n            history.push(item.itemId)\n\n            setActiveItemId(item.itemId)\n          }}\n        />\n      </div>\n      <main className=\"main\">{children}</main>\n    </div>\n  )\n}\n\nexport default Layout\n","import React from 'react'\nimport './App.scss'\nimport { HashRouter as Router, Switch, Route } from 'react-router-dom'\n\nimport { Layout } from 'commons'\nimport { routes } from 'configs'\n\nconst App = () => {\n  return (\n    <Router>\n      <Layout>\n        <Switch>\n          {routes.map((route) => (\n            <Route key={route.path} path={route.path} exact={route.exact} component={route.page} />\n          ))}\n        </Switch>\n      </Layout>\n    </Router>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.scss'\nimport App from './App'\n\nimport { Client as Styletron } from 'styletron-engine-atomic'\nimport { Provider as StyletronProvider } from 'styletron-react'\nimport { DarkTheme, BaseProvider } from 'baseui'\n\nconst engine = new Styletron()\n\nReactDOM.render(\n  <React.StrictMode>\n    <StyletronProvider value={engine}>\n      <BaseProvider theme={DarkTheme}>\n        <App />\n      </BaseProvider>\n    </StyletronProvider>\n  </React.StrictMode>,\n  document.getElementById('root'),\n)\n"],"sourceRoot":""}